# HOT-100

#### No.xx [题目]()



#### No.46 [二叉树的最大路径](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

* 解题思路：

  二叉树具有最大和的路径，这条路径可能包括根节点，也可能只存在于某个子树中。具体而言，这条最大和路径的节点分布，有下面五种情况：

  * 只含有根节点root，最大路径和为root->val
  * 只含有左子树上的节点，和为left_max
  * 只含有右子树上的节点，和为right_max
  * 含有从根**出发**的某条路径，和为root->val+max(left_max, right_max)
  * 最大和路径在左右子树都存在节点，自然要通过根节点衔接，最大和为root->val+left_max,+right_max

  那么，我需要做的事情就是想办法把一棵树在这五情况下的最大路径和求出来。代码的核心函数为dfs，这个函数输入为一棵树的根节点，返回值是**所有从根节点出发的路径中，具有最大路径和的值**

  ```cpp
  class Solution {
  public:
      int ans = INT_MIN;
  
      int dfs(TreeNode* root) {
          if(nullptr == root) {
              return 0;
          }
          // 分别计算左右子树各能贡献多少最大路径和，对应于5种情况的前2种
          int left_max = max(0, dfs(root->left));
          int right_max = max(0, dfs(root->right));
          
          // 计算包含根节点的路径，对应于5种情况的后3种
          ans = max(ans, root->val+left_max+right_max);
          
          // 返回从根节点出发，具有最大路径和的值
          return root->val+max(0, max(left_max, right_max));
      }
      
      int maxPathSum(TreeNode* root) {
          dfs(root);
          return ans;
      }
  };
  ```

#### No.50 [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

* 解法一：快慢指针

  ```cpp
  class Solution {
  public:
      bool hasCycle(ListNode *head) {
          auto slow = head;
          auto fast = head;
          while(fast && fast->next) {
              slow = slow->next;
              fast = fast->next->next;
              if(slow == fast) {
                  return true;
              }
          }
          return false;
      }
  };
  ```


#### No.72 [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

* 解题思路：典型的动态规划问题，可以看成是凑硬币的翻版。假设dp[n]表示n能够用完全平方数表示的最小个数，则有如下递推公式：
  $$
  dp[i]=min\left \{ dp[i-1]+1,dp[i-4]+1,dp[i-9]+1 \dots \right \}
  $$

* 解法一：动态规划法

  ```cpp
  class Solution {
  public:
      int numSquares(int n) {
          vector<int> dp(n+1, 0);
          for(int i = 0; i <= n; i++) {
              dp[i] = i;
          }
          for(int i = 1; i <= n; i++) {
              for(int j = 1; j*j <= i; j++) {
                  dp[i] = min(dp[i], dp[i-j*j]+1);
              }
          }
          return dp.back();
      }
  };
  ```

#### No.80 [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

* 解题思路：该题基本上属于第72题的翻版，**动态规划**或者**BFS**均可求解

* 解法一：动态规划

  ```cpp
  class Solution {
  public:
      int coinChange(vector<int>& coins, int amount) {
          vector<int> dp(amount+1, 0);
  
          for(int i = 1; i <= amount; i++) {
              int need_coins = INT_MAX;
              for(int j = 0; j < coins.size(); j++) {
                  if(coins[j]>i || -1 == dp[i-coins[j]]) {
                      continue;
                  } else if (dp[i - coins[j]] != -1) {
                      need_coins = min(need_coins, dp[i-coins[j]] + 1);
                  } 
              }
              dp[i] = INT_MAX==need_coins? -1 : need_coins;
          }
          return dp.back();
      }
  };
  ```

  



